#include "shader_program.h"
#include "utils/file_system.h"
#include "memory/memory.h"

namespace lambda
{
  namespace asset
  {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ShaderProgram::ShaderProgram(VioletShaderProgram program) :
      program_(program)
    {
      // Reset the data if it is supposed to be GPU only.
      if (getFlag(VioletFlags::kGPUOnly))
      {
        program_.blobs.clear();
        program_.reflection = VioletShaderReflection();
      }
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void ShaderProgram::setFlag(const VioletFlags & flag, bool value)
    {
      if (value == true)
        bit_set_.set((uint32_t)flag);
      else
        bit_set_.clear((uint32_t)flag);
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    bool ShaderProgram::getFlag(const VioletFlags & flag) const
    {
      return bit_set_.get((uint32_t)flag);
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    const VioletShaderProgram& ShaderProgram::getProgram() const
    {
      return program_;
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    String ShaderProgram::getPath() const
    {
      return program_.file_path;
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Vector<String> ShaderProgram::getDefines() const
    {
      return program_.defines;
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ShaderStages ShaderProgram::getStage() const
    {
      return program_.stage;
    }










    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    VioletShaderProgramHandle ShaderProgramManager::create(Name name, ShaderProgram shader_program)
    {
      return VioletShaderProgramHandle(foundation::Memory::construct<ShaderProgram>(shader_program), name);
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    VioletShaderProgramHandle ShaderProgramManager::get(uint64_t hash)
    {
      VioletShaderProgram program = manager_.GetShaderProgram(hash);
      return create(program.file_path, program);
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void ShaderProgramManager::destroy(VioletShaderProgramHandle shader_program)
    {
      foundation::Memory::destruct<ShaderProgram>(shader_program.get());
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ShaderProgramManager* ShaderProgramManager::getInstance()
    {
      static ShaderProgramManager* s_instance = foundation::Memory::construct<ShaderProgramManager>();
      return s_instance;
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    VioletShaderManager & ShaderProgramManager::getManager()
    {
      return manager_;
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    const VioletShaderManager & ShaderProgramManager::getManager() const
    {
      return manager_;
    }
  }
}